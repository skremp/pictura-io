/**
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

/**
 * Originally written by Riyad Kalla (https://github.com/thebuzzmedia/imgscalr)
 * and licensed under the Apache License, Version 2.0.
 */
package io.pictura.servlet;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Transparency;
import java.awt.color.ColorSpace;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.AreaAveragingScaleFilter;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ByteLookupTable;
import java.awt.image.ColorConvertOp;
import java.awt.image.ColorModel;
import java.awt.image.ConvolveOp;
import java.awt.image.ImagingOpException;
import java.awt.image.IndexColorModel;
import java.awt.image.Kernel;
import java.awt.image.LookupOp;
import java.awt.image.Raster;
import java.awt.image.RasterFormatException;
import java.awt.image.RescaleOp;
import java.awt.image.WritableRaster;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Random;
import java.util.Set;
import javax.imageio.ImageIO;

/**
 * Class used to implement performant, high-quality and intelligent image
 * scaling and manipulation algorithms in native Java 2D.
 * 
 * <p>
 * This class utilizes the Java2D "best practices" for image manipulation,
 * ensuring that all operations (even most user-provided {@link BufferedImageOp}'
 * s) are hardware accelerated if provided by the platform and host-VM.
 * </p>
 * 
 * <h3>Image Quality</h3>
 * This class implements a few different methods for scaling an image, providing
 * either the best-looking result, the fastest result or a balanced result
 * between the two depending on the scaling hint provided (see {@link Method}).
 * 
 * <p>
 * This class also implements an optimized version of the incremental scaling
 * algorithm presented by Chris Campbell in his 
 * <a href="http://today.java.net/pub/a/today/2007/04/03/perils-of-image-getscaledinstance.html">
 * Perils of Image.getScaledInstance()</a> article in order to give the 
 * best-looking image resize results (e.g. generating thumbnails that aren't 
 * blurry or jagged).
 * </p>
 * 
 * <p>
 * The results generated by Pictura using this method, as compared to a single
 * {@link RenderingHints#VALUE_INTERPOLATION_BICUBIC} scale operation look much
 * better, especially when using the {@link Method#ULTRA_QUALITY} method.
 * </p>
 * 
 * <p>
 * Only when scaling using the {@link Method#AUTOMATIC} method will this class
 * look at the size of the image before selecting an approach to scaling the
 * image. If {@link Method#QUALITY} is specified, the best-looking algorithm
 * possible is always used.
 * </p>
 * 
 * Minor modifications are made to Campbell's original implementation in the
 * form of:
 * <ol>
 * <li>Instead of accepting a user-supplied interpolation method,
 * {@link RenderingHints#VALUE_INTERPOLATION_BICUBIC} interpolation is always
 * used. This was done after A/B comparison testing with large images
 * down-scaled to thumbnail sizes showed noticeable "blurring" when BILINEAR
 * interpolation was used. Given that Campbell's algorithm is only used in
 * QUALITY mode when down-scaling, it was determined that the user's expectation
 * of a much less blurry picture would require that BICUBIC be the default
 * interpolation in order to meet the QUALITY expectation.</li>
 * <li>After each iteration of the do-while loop that incrementally scales the
 * source image down, an explicit effort is made to call
 * {@link BufferedImage#flush()} on the interim temporary {@link BufferedImage}
 * instances created by the algorithm in an attempt to ensure a more complete GC
 * cycle by the VM when cleaning up the temporary instances (this is in addition
 * to disposing of the temporary {@link Graphics2D} references as well).</li>
 * <li>Extensive comments have been added to increase readability of the
 * code.</li>
 * <li>Variable names have been expanded to increase readability of the
 * code.</li>
 * </ol>
 * 
 * <p>
 * <strong>NOTE</strong>: This class does not call {@link BufferedImage#flush()}
 * on any of the <em>source images</em> passed in by calling code; it is up to
 * the original caller to dispose of their source images when they are no longer
 * needed so the VM can most efficiently GC them.
 * </p>
 * 
 * <h3>Image Proportions</h3>
 * All scaling operations implemented by this class maintain the proportions of
 * the original image unless a mode of {@link Mode#FIT_EXACT} is specified; in
 * which case the orientation and proportion of the source image is ignored and
 * the image is stretched (if necessary) to fit the exact dimensions given.
 * 
 * When not using {@link Mode#FIT_EXACT}, in order to maintain the
 * proportionality of the original images, this class implements the following
 * behavior:
 * <ol>
 * <li>If the image is LANDSCAPE-oriented or SQUARE, treat the
 * <code>targetWidth</code> as the primary dimension and re-calculate the
 * <code>targetHeight</code> regardless of what is passed in.</li>
 * <li>If image is PORTRAIT-oriented, treat the <code>targetHeight</code> as the
 * primary dimension and re-calculate the <code>targetWidth</code> regardless of
 * what is passed in.</li>
 * <li>If a {@link Mode} value of {@link Mode#FIT_TO_WIDTH} or
 * {@link Mode#FIT_TO_HEIGHT} is passed in to the <code>resize</code> method,
 * the image's orientation is ignored and the scaled image is fit to the
 * preferred dimension by using the value passed in by the user for that
 * dimension and recalculating the other (regardless of image orientation). This
 * is useful, for example, when working with PORTRAIT oriented images that you
 * need to all be the same width or visa-versa (e.g. showing user profile
 * pictures in a directory listing).</li>
 * </ol>
 * 
 * <h3>Optimized Image Handling</h3>
 * Java2D provides support for a number of different image types defined as
 * <code>BufferedImage.TYPE_*</code> variables, unfortunately not all image
 * types are supported equally in the Java2D rendering pipeline.
 *
 * <p>
 * Some more obscure image types either have poor or no support, leading to
 * severely degraded quality and processing performance when an attempt is made
 * by Pictura to create a scaled instance <em>of the same type</em> as the
 * source image. In many cases, especially when applying {@link BufferedImageOp}
 * s, using poorly supported image types can even lead to exceptions or total
 * corruption of the image (e.g. solid black image).
 * </p>
 * 
 * Pictura specifically accounts for and automatically hands
 * <strong>ALL</strong> of these pain points for you internally by shuffling all
 * images into one of two types:
 * <ol>
 * <li>{@link BufferedImage#TYPE_INT_RGB}</li>
 * <li>{@link BufferedImage#TYPE_INT_ARGB}</li>
 * </ol>
 * depending on if the source image utilizes transparency or not. This is a
 * recommended approach by the Java2D team for dealing with poorly (or non)
 * supported image types. More can be read about this issue
 * <a href="http://www.mail-archive.com/java2d-interest@capra.eng.sun.com/msg05621.html">here</a>.
 * 
 * <p>This is also the reason we recommend using
 * {@link #apply(BufferedImage, BufferedImageOp...)} to apply your own ops to
 * images even if you aren't using Pictura for anything else.</p>
 * 
 * <h3>GIF Transparency</h3>
 * Unfortunately in Java 6 and earlier, support for GIF's
 * {@link IndexColorModel} is sub-par, both in accurate color-selection and in
 * maintaining transparency when moving to an image of type
 * {@link BufferedImage#TYPE_INT_ARGB}; because of this issue when a GIF image
 * is processed by Pictura and the result saved as a GIF file (instead of PNG),
 * it is possible to lose the alpha channel of a transparent image or in the
 * case of applying an optional {@link BufferedImageOp}, lose the entire picture
 * all together in the result (long standing JDK bugs are filed for all of these
 * issues).
 * 
 * <p>Pictura currently does nothing to work around this manually because it is a
 * defect in the native platform code itself. Fortunately it looks like the
 * issues are half-fixed in Java 7 and any manual workarounds we could attempt
 * internally are relatively expensive, in the form of hand-creating and setting
 * RGB values pixel-by-pixel with a custom {@link ColorModel} in the scaled
 * image. This would lead to a very measurable negative impact on performance
 * without the caller understanding why.</p>
 * 
 * <p><strong>Workaround</strong>: A workaround to this issue with all version of
 * Java is to simply save a GIF as a PNG; no change to your code needs to be
 * made except when the image is saved out, e.g. using {@link ImageIO}.</p>
 * 
 * <p>When a file type of "PNG" is used, both the transparency and high color
 * quality will be maintained as the PNG code path in Java2D is superior to the
 * GIF implementation.</p>
 * 
 * <p>If the issue with optional {@link BufferedImageOp}s destroying GIF image
 * content is ever fixed in the platform, saving out resulting images as GIFs
 * should suddenly start working.</p>
 * 
 * More can be read about the issue <a href="http://gman.eichberger.de/2007/07/transparent-gifs-in-java.html">
 * here</a> and <a href="http://ubuntuforums.org/archive/index.php/t-1060128.html">here</a>.
 * 
 * <h3>Thread Safety</h3>
 * The {@link Pictura} class is <strong>thread-safe</strong> (as all the methods
 * are <code>static</code>); this class maintains no internal state while
 * performing any of the provided operations and is safe to call simultaneously
 * from multiple threads.
 *
 * @author Steffen Kremp
 * @author Riyad Kalla (https://github.com/thebuzzmedia/imgscalr)
 *
 * @since 1.0
 */
public final class Pictura {

    // Declared to prevent instantiation.
    private Pictura() {
    }

    /**
     * A {@link BufferedImageOp} using a very light "blur" kernel that acts like
     * an anti-aliasing filter (softens the image a bit) when applied to an
     * image.
     * <p/>
     * A common request by users of the library was that they wished to "soften"
     * resulting images when scaling them down drastically. After quite a bit of
     * A/B testing, the kernel used by this Op was selected as the closest match
     * for the target which was the softer results from the deprecated
     * {@link AreaAveragingScaleFilter} (which is used internally by the
     * deprecated {@link Image#getScaledInstance(int, int, int)} method in the
     * JDK).
     * <p/>
     * This ConvolveOp uses a 3x3 kernel with the values:
     * <table cellpadding="4" border="1">
     * <tr>
     * <td>.0f</td>
     * <td>.08f</td>
     * <td>.0f</td>
     * </tr>
     * <tr>
     * <td>.08f</td>
     * <td>.68f</td>
     * <td>.08f</td>
     * </tr>
     * <tr>
     * <td>.0f</td>
     * <td>.08f</td>
     * <td>.0f</td>
     * </tr>
     * </table>
     * <p/>
     * For those that have worked with ConvolveOps before, this Op uses the
     * {@link ConvolveOp#EDGE_NO_OP} instruction to not process the pixels along
     * the very edge of the image (otherwise EDGE_ZERO_FILL would create a
     * black-border around the image). If you have not worked with a ConvolveOp
     * before, it just means this default OP will "do the right thing" and not
     * give you garbage results.
     * <p/>
     * This ConvolveOp uses no {@link RenderingHints} values as internally the
     * {@link ConvolveOp} class only uses hints when doing a color conversion
     * between the source and destination {@link BufferedImage} targets. Pictura
     * allows the {@link ConvolveOp} to create its own destination image every
     * time, so no color conversion is ever needed and thus no hints.
     * <h3>Performance</h3>
     * Use of this (and other) {@link ConvolveOp}s are hardware accelerated when
     * possible. For more information on if your image op is hardware
     * accelerated or not, check the source code of the underlying JDK class
     * that actually executes the Op code, <a href=
     * "http://www.docjar.com/html/api/sun/awt/image/ImagingLib.java.html"
     * >sun.awt.image.ImagingLib</a>.
     * <h3>Known Issues</h3>
     * In all versions of Java (tested up to Java 7 preview Build 131), running
     * this op against a GIF with transparency and attempting to save the
     * resulting image as a GIF results in a corrupted/empty file. The file must
     * be saved out as a PNG to maintain the transparency.
     */
    static final BufferedImageOp OP_ANTIALIAS = new ConvolveOp(
	    new Kernel(3, 3, new float[]{.0f, .08f, .0f, .08f, .68f, .08f,
		.0f, .08f, .0f}), ConvolveOp.EDGE_NO_OP, null);

    static final BufferedImageOp OP_SHARPEN = new ConvolveOp(
	    new Kernel(3, 3, new float[]{.0f, -.2f, .0f, -.2f, 1.8f, -.2f,
		.0f, -.2f, .0f}), ConvolveOp.EDGE_NO_OP, null);

    /**
     * A {@link BufferedImageOp} used to convert a given image to a black and
     * white image with a treshold of "127".
     */
    static final BufferedImageOp OP_THRESHOLD = getOpThreshold(127);

    /**
     * A {@link BufferedImageOp} used to invert the colors of any input image.
     */
    static final BufferedImageOp OP_INVERT = new RescaleOp(-1.0f, 255f, null);

    /**
     * A {@link BufferedImageOp} used to make any input image 10% darker.
     * <p/>
     * This operation can be applied multiple times in a row if greater than 10%
     * changes in brightness are desired.
     */
    static final BufferedImageOp OP_DARKER = new RescaleOp(0.9f, 0, null);

    /**
     * A {@link BufferedImageOp} used to make any input image 10% brighter.
     * <p/>
     * This operation can be applied multiple times in a row if greater than 10%
     * changes in brightness are desired.
     */
    static final BufferedImageOp OP_BRIGHTER = new RescaleOp(1.1f, 0, null);

    /**
     * A {@link BufferedImageOp} used to convert any image to a grayscale color
     * palette.
     * <p/>
     * Applying this op multiple times to the same image has no compounding
     * effects.
     */
    static final BufferedImageOp OP_GRAYSCALE = new ColorConvertOp(
	    ColorSpace.getInstance(ColorSpace.CS_GRAY), null);

    /**
     * A {@link BufferedImageOp} used to convert any image to a luminosity
     * grayscale image.
     * <p/>
     * The luminosity method is a more sophisticated version of the average
     * method. It also averages the values, but it forms a weighted average to
     * account for human perception. Weâ€™re more sensitive to green than other
     * colors, so green is weighted most heavily. The formula for luminosity is
     * 0.21 R + 0.72 G + 0.07 B.
     */
    static final BufferedImageOp OP_GRAYSCALE_LUMINOSITY = new PointImageOp() {

        @Override
        public int filterRGB(int x, int y, int rgb) {
            int drgb = (int) ((((rgb >> 16) & 0xFF) * 0.21f) 
                    + (((rgb >> 8) & 0xFF) * 0.72f) 
                    + (((rgb) & 0xFF) * 0.07f));
            
            return ((255 & 0xFF) << 24)
                    | ((drgb & 0xFF) << 16)
                    | ((drgb & 0xFF) << 8)
                    | ((drgb & 0xFF));
        }

    };

    /**
     * A {@link BufferedImageOp} used to append a sunset effect to an image by
     * reducing the green and blue color value.
     */
    static final BufferedImageOp OP_SUNSET = new PointImageOp() {

        @Override
        public int filterRGB(int x, int y, int rgb) {
            return (((rgb >> 24) & 0xFF) << 24) 
                    | (((rgb >> 16) & 0xFF) << 16) 
                    | ((int) (((rgb >> 8) & 0xFF) * 0.85f) << 8) 
                    | (int) (((rgb) & 0xFF) * 0.85f);
        }
    };
    
    /**
     * A {@link BufferedImageOp} used to convert any image to a sepia tone
     * image.
     */
    static final BufferedImageOp OP_SEPIA = new PointImageOp() {

        @Override
        public int filterRGB(int x, int y, int rgb) {
            int gray = (int) (((rgb >> 16) & 0xFF) * 0.3 
                    + ((rgb >> 8) & 0xFF) * 0.59 
                    + ((rgb) & 0xFF) * 0.11);
            
            Color cg = new Color(gray, gray, gray);

            return new Color(cg.getRed(), (int) (cg.getGreen() * 0.95),
                    (int) (cg.getBlue() * 0.78)).getRGB();
        }
    };

    /**
     * A {@link BufferedImageOp} used to posterize any image.
     */
    static final BufferedImageOp OP_POSTERIZE = new PointImageOp() {

	private final static int NUM_LEVELS = 6;
	private final int[] LEVELS = new int[256];

	{
	    for (int i = 0; i < 256; i++) {
		LEVELS[i] = 255 * (NUM_LEVELS * i / 256) / (NUM_LEVELS - 1);
	    }
	}

	@Override
	public int filterRGB(int x, int y, int rgb) {
	    int a = rgb & 0xff000000;
	    int r = (rgb >> 16) & 0xff;
	    int g = (rgb >> 8) & 0xff;
	    int b = rgb & 0xff;
            
	    r = LEVELS[r];
	    g = LEVELS[g];
	    b = LEVELS[b];
	    
            return a | (r << 16) | (g << 8) | b;
	}

    };

    /**
     * A {@link BufferedImageOp} used to pixelate any image.
     */
    static final BufferedImageOp OP_PIXELATE = getOpPixelate(10);
    
    /**
     * A {@link BufferedImageOp} used to append some noise to any image.
     */
    static final BufferedImageOp OP_NOISE = new PointImageOp() {

	private static final int AMOUNT = 20;
	private static final int DENSITY = 1;

	private final Random rnd = new Random();

	@Override
	public int filterRGB(int x, int y, int rgb) {
	    if (rnd.nextFloat() <= DENSITY) {
		return (rgb & 0xff000000) | (random((rgb >> 16) & 0xff) << 16)
			| (random((rgb >> 8) & 0xff) << 8) | random(rgb & 0xff);
	    }
	    return rgb;
	}

	private int random(int x) {
	    x += (int) (rnd.nextGaussian() * AMOUNT);
	    return x < 0 ? 0 : x > 0xff ? 0xff : x;
	}
    };

    // https://github.com/ajmas/JH-Labs-Java-Image-Filters/blob/master/src/com/jhlabs/image/WholeImageFilter.java
    // https://github.com/ajmas/JH-Labs-Java-Image-Filters/blob/master/src/com/jhlabs/image/MedianFilter.java
    static final BufferedImageOp OP_MEDIAN = new ImageOp() {
        
        @Override
        public BufferedImage filter(BufferedImage src, BufferedImage dest) {
            int width = src.getWidth();
            int height = src.getHeight();

            Rectangle transformedSpace = new Rectangle(0, 0, width, height);

            if (dest == null) {
                ColorModel dstCM = src.getColorModel();
                dest = new BufferedImage(dstCM, dstCM.createCompatibleWritableRaster(
                        transformedSpace.width, transformedSpace.height), 
                        dstCM.isAlphaPremultiplied(), null);
            }

            int index = 0;
            
            int[] argb = new int[9];
            int[] r = new int[9];
            int[] g = new int[9];
            int[] b = new int[9];
            
            int[] inPixels = getRGB(src, 0, 0, width, height, null);
            int[] outPixels = new int[width * height];
            
            for (int y = 0; y < height; y++) {
                for (int x = 0; x < width; x++) {
                    int k = 0;
                    for (int dy = -1; dy <= 1; dy++) {
                        int iy = y + dy;
                        if (0 <= iy && iy < height) {
                            int ioffset = iy * width;
                            for (int dx = -1; dx <= 1; dx++) {
                                int ix = x + dx;
                                if (0 <= ix && ix < width) {
                                    int rgb = inPixels[ioffset + ix];
                                    argb[k] = rgb;
                                    r[k] = (rgb >> 16) & 0xff;
                                    g[k] = (rgb >> 8) & 0xff;
                                    b[k] = rgb & 0xff;
                                    k++;
                                }
                            }
                        }
                    }
                    while (k < 9) {
                        argb[k] = 0xff000000;
                        r[k] = g[k] = b[k] = 0;
                        k++;
                    }
                    outPixels[index++] = argb[rgbMedian(r, g, b)];
                }
            }
            
            setRGB(dest, 0, 0, transformedSpace.width, transformedSpace.height, outPixels);
            return dest;
        }        
        
        private int rgbMedian(int[] r, int[] g, int[] b) {
            int sum, index = 0, min = Integer.MAX_VALUE;

            for (int i = 0; i < 9; i++) {
                sum = 0;
                for (int j = 0; j < 9; j++) {
                    sum += Math.abs(r[i] - r[j]);
                    sum += Math.abs(g[i] - g[j]);
                    sum += Math.abs(b[i] - b[j]);
                }
                if (sum < min) {
                    min = sum;
                    index = i;
                }
            }
            return index;
        }
    };
    
    // https://code.google.com/p/jalbum-autocorrect/source/browse/AutoCorrection/src/net/jalbum/filters/auto/AutoCorrectionFilter.java?r=6
    static final BufferedImageOp OP_AUTO_COLOR = new ImageOp() {

	private static final int AUTO_COLOR_VALUE = 20;

	@Override
	public BufferedImage filter(BufferedImage src, BufferedImage dest) {
	    int[] minIndices = new int[3];

	    Arrays.fill(minIndices, 0);
	    boolean colorsPossible = false;

	    int[] largestOccs = new int[3];

	    int[] pixels = new int[src.getWidth() * src.getHeight()];
	    src.getRGB(0, 0, src.getWidth(), src.getHeight(), pixels, 0, src.getWidth());

	    int[][] colors = getColors(pixels, largestOccs);

	    int[] r = new int[256];
	    int[] g = new int[256];
	    int[] b = new int[256];

	    for (int i = 0; i < 256; i++) {
		r[i] = colors[0][i];
		g[i] = colors[1][i];
		b[i] = colors[2][i];
	    }

	    if (largestOccs[0] > (255 - AUTO_COLOR_VALUE)
		    || largestOccs[0] < AUTO_COLOR_VALUE) {
		minIndices[0] = getMinIndex(r);
		colorsPossible = true;
	    }
	    if (largestOccs[1] > (255 - AUTO_COLOR_VALUE)
		    || largestOccs[1] < AUTO_COLOR_VALUE) {
		minIndices[1] = getMinIndex(g);
		colorsPossible = true;
	    }
	    if (largestOccs[2] > (255 - AUTO_COLOR_VALUE)
		    || largestOccs[2] < AUTO_COLOR_VALUE) {
		minIndices[2] = getMinIndex(b);
		colorsPossible = true;
	    }

	    if (colorsPossible) {
		for (int i = 0; i < pixels.length; i++) {
		    int argb = pixels[i];

		    int ax = (argb >> 24) & 0xff;
		    int rx = (argb >> 16) & 0xff;
		    int gx = (argb >> 8) & 0xff;
		    int bx = argb & 0xff;

		    rx -= minIndices[0];
		    gx -= minIndices[1];
		    bx -= minIndices[2];

		    int[] clipped = clamp(rx, gx, bx);

		    pixels[i] = (ax << 24) | (clipped[0] << 16) | (clipped[1] << 8) | clipped[2];

		}
	    }

	    dest.setRGB(0, 0, src.getWidth(), src.getHeight(), pixels, 0, src.getWidth());
	    return dest;
	}

	private int getMinIndex(int[] arr) {
	    int min = 0;
	    int i = -1;
	    while (min == 0) {
		i++;
		min = arr[i];
	    }
	    if (i > AUTO_COLOR_VALUE) {
		i = AUTO_COLOR_VALUE;
	    }
	    return i;
	}

    };

    // https://code.google.com/p/jalbum-autocorrect/source/browse/AutoCorrection/src/net/jalbum/filters/auto/AutoCorrectionFilter.java?r=6
    static final BufferedImageOp OP_AUTO_LEVEL = new ImageOp() {

	@Override
	public BufferedImage filter(BufferedImage src, BufferedImage dest) {
	    int[] pixels = new int[src.getWidth() * src.getHeight()];
	    src.getRGB(0, 0, src.getWidth(), src.getHeight(), pixels, 0, src.getWidth());

	    int[] rPixels = getColorHistogram(pixels, 16);
	    int[] gPixels = getColorHistogram(pixels, 8);
	    int[] bPixels = getColorHistogram(pixels, 0);

	    int clipNum = round(pixels.length * 0.001);
	    double[] factors = new double[6];

	    int max = getMaximum(clipNum, rPixels);
	    int min = getMinimum(clipNum, rPixels);

	    factors[0] = 255.0 / (max - min); //contrastR
	    factors[1] = 127.5 - ((max + min) / 2.0); // brightnessR

	    max = getMaximum(clipNum, gPixels);
	    min = getMinimum(clipNum, gPixels);

	    factors[2] = 255.0 / (max - min); //contrastG
	    factors[3] = 127.5 - ((max + min) / 2.0); // brightnessG

	    max = getMaximum(clipNum, bPixels);
	    min = getMinimum(clipNum, bPixels);

	    factors[4] = 255.0 / (max - min); //contrastB
	    factors[5] = 127.5 - ((max + min) / 2.0); // brightnessB

	    for (int i = 0; i < pixels.length; i++) {
		int argb = pixels[i];

		int a = (argb >> 24) & 0xff;
		int r = (argb >> 16) & 0xff;
		int g = (argb >> 8) & 0xff;
		int b = argb & 0xff;

		int rn = (int) (factors[0] * (r + factors[1] - 127.5) + 127.5);
		int gn = (int) (factors[2] * (g + factors[3] - 127.5) + 127.5);
		int bn = (int) (factors[4] * (b + factors[5] - 127.5) + 127.5);

		int[] clipped = clamp(rn, gn, bn);

		pixels[i] = (a << 24) | (clipped[0] << 16) | (clipped[1] << 8) | clipped[2];

	    }

	    dest.setRGB(0, 0, src.getWidth(), src.getHeight(), pixels, 0, src.getWidth());
	    return dest;
	}

    };

    // https://code.google.com/p/jalbum-autocorrect/source/browse/AutoCorrection/src/net/jalbum/filters/auto/AutoCorrectionFilter.java?r=6
    static final BufferedImageOp OP_AUTO_CONTRAST = new ImageOp() {

	@Override
	public BufferedImage filter(BufferedImage src, BufferedImage dest) {
	    int[] pixels = new int[src.getWidth() * src.getHeight()];
	    src.getRGB(0, 0, src.getWidth(), src.getHeight(), pixels, 0, src.getWidth());

	    int[] lumPixels = getLuminanceArray(pixels);

	    int clipNum = round(pixels.length * 0.001);
	    int max = getMaximum(clipNum, lumPixels);
	    int min = getMinimum(clipNum, lumPixels);

	    double contrast = 255.0 / (max - min);
	    double brightness = 127.5 - ((max + min) / 2.0);

	    for (int i = 0; i < pixels.length; i++) {
		int argb = pixels[i];

		int a = (argb >> 24) & 0xff;
		int r = (argb >> 16) & 0xff;
		int g = (argb >> 8) & 0xff;
		int b = argb & 0xff;

		double Y = 0.299 * r + 0.587 * g + 0.114 * b;
		double Cb = -0.168736 * r - 0.331264 * g + 0.5 * b;
		double Cr = 0.5 * r - 0.418688 * g - 0.081312 * b;

		Y = contrast * (Y + brightness - 127.5) + 127.5;

		int rn = (int) (Y + 1.402 * Cr + 0.5);
		int gn = (int) (Y - 0.3441 * Cb - 0.7141 * Cr + 0.5);
		int bn = (int) (Y + 1.772 * Cb + 0.5);

		int[] clipped = clamp(rn, gn, bn);

		pixels[i] = (a << 24) | (clipped[0] << 16) | (clipped[1] << 8) | clipped[2];
	    }

	    dest.setRGB(0, 0, src.getWidth(), src.getHeight(), pixels, 0, src.getWidth());
	    return dest;
	}

    };

    static final BufferedImageOp getOpRescale(final float scaleFactor) {
	return new RescaleOp(scaleFactor, 0, null);
    }

    static final BufferedImageOp getOpGamma(final float value) {
	byte[] table = new byte[256];
	for (int i = 0; i < table.length; i++) {
	    table[i] = (byte) (255 * Math.pow(i / 255.0, value));
	}
	return new LookupOp(new ByteLookupTable(0, table), null);
    }

    static final BufferedImageOp getOpSaturation(final float value) {
        return new PointImageOp() {
            @Override
            public int filterRGB(int x, int y, int rgb) {
                if (value != 1) {
                    int a = rgb & 0xff000000;
                    int r = (rgb >> 16) & 0xff;
                    int g = (rgb >> 8) & 0xff;
                    int b = rgb & 0xff;
                    int v = (r + g + b) / 3; // or a better brightness calculation if you prefer

                    int[] rgb2 = clamp((int) (v + value * (r - v)),
                            (int) (v + value * (g - v)),
                            (int) (v + value * (b - v)));

                    return a | (rgb2[0] << 16) | (rgb2[1] << 8) | rgb2[2];
                }
                return rgb;
            }
        };
    }
    
    static final BufferedImageOp getOpPixelate(final int value) {
	return new ImageOp() {
	    
	    @Override
	    public BufferedImage filter(BufferedImage src, BufferedImage dest) {
		Raster r = src.getData();
		WritableRaster wr = r.createCompatibleWritableRaster();

		// Loop through every PIX_SIZE pixels, in both x and y directions
		for (int y = 0; y < r.getHeight(); y += value) {
		    for (int x = 0; x < r.getWidth(); x += value) {

			// Copy the pixel
			double[] pixel = new double[r.getNumBands()];
			pixel = r.getPixel(x, y, pixel);

			// "Paste" the pixel onto the surrounding PIX_SIZE by PIX_SIZE neighbors
			// Also make sure that our loop never goes outside the bounds of the image
			for (int yd = y; (yd < y + value) && (yd < wr.getHeight()); yd++) {
			    for (int xd = x; (xd < x + value) && (xd < wr.getWidth()); xd++) {
				wr.setPixel(xd, yd, pixel);
			    }
			}
		    }
		}

		dest.setData(wr);
		return dest;
	    }
	};
    }
    
    static final BufferedImageOp getOpThreshold(final int value) {
	return new PointImageOp() {

	    private static final int W = 0xffffffff;
	    private static final int B = 0x00000000;

	    @Override
	    public int filterRGB(int x, int y, int rgb) {

		float r = ((rgb >> 16) & 0xFF) * 0.333f;
		float g = ((rgb >> 8) & 0xFF) * 0.333f;
		float b = ((rgb) & 0xFF) * 0.333f;

		int drgb = (int) (r + g + b);

		return drgb < value ? B : W;
	    }
	};
    }
    
    /**
     * Used to define the different scaling hints that the algorithm can use.
     */
    public static enum Method {

	/**
	 * Used to indicate that the scaling implementation should decide which
	 * method to use in order to get the best looking scaled image in the
	 * least amount of time.
	 * <p>
	 * The scaling algorithm will use the
	 * {@link Pictura#THRESHOLD_QUALITY_BALANCED} or
	 * {@link Pictura#THRESHOLD_BALANCED_SPEED} thresholds as cut-offs to
	 * decide between selecting the <code>QUALITY</code>,
	 * <code>BALANCED</code> or <code>SPEED</code> scaling algorithms.
	 * </p><p>
	 * By default the thresholds chosen will give nearly the best looking
	 * result in the fastest amount of time. We intend this method to work
	 * for 80% of people looking to scale an image quickly and get a good
	 * looking result.</p>
	 */
	AUTOMATIC,
	/**
	 * Used to indicate that the scaling implementation should scale as fast
	 * as possible and return a result. For smaller images (800px in size)
	 * this can result in noticeable aliasing but it can be a few magnitudes
	 * times faster than using the QUALITY method.
	 */
	SPEED,
	/**
	 * Used to indicate that the scaling implementation should use a scaling
	 * operation balanced between SPEED and QUALITY. Sometimes SPEED looks
	 * too low quality to be useful (e.g. text can become unreadable when
	 * scaled using SPEED) but using QUALITY mode will increase the
	 * processing time too much. This mode provides a "better than SPEED"
	 * quality in a "less than QUALITY" amount of time.
	 */
	BALANCED,
	/**
	 * Used to indicate that the scaling implementation should do everything
	 * it can to create as nice of a result as possible. This approach is
	 * most important for smaller pictures (800px or smaller) and less
	 * important for larger pictures as the difference between this method
	 * and the SPEED method become less and less noticeable as the
	 * source-image size increases. Using the AUTOMATIC method will
	 * automatically prefer the QUALITY method when scaling an image down
	 * below 800px in size.
	 */
	QUALITY,
	/**
	 * Used to indicate that the scaling implementation should go above and
	 * beyond the work done by {@link Method#QUALITY} to make the image look
	 * exceptionally good at the cost of more processing time. This is
	 * especially evident when generating thumbnails of images that look
	 * jagged with some of the other {@link Method}s (even
	 * {@link Method#QUALITY}).
	 */
	ULTRA_QUALITY;
    }

    /**
     * Used to define the different modes of resizing that the algorithm can
     * use.
     */
    public static enum Mode {

	/**
	 * Used to indicate that the scaling implementation should calculate
	 * dimensions for the resultant image by looking at the image's
	 * orientation and generating proportional dimensions that best fit into
	 * the target width and height given
	 *
	 * See "Image Proportions" in the {@link Pictura} class description for
	 * more detail.
	 */
	AUTOMATIC,
	/**
	 * Used to fit the image to the exact dimensions given regardless of the
	 * image's proportions. If the dimensions are not proportionally
	 * correct, this will introduce vertical or horizontal stretching to the
	 * image.
	 * <p>
	 * It is recommended that you use one of the other <code>FIT_TO</code>
	 * modes or {@link Mode#AUTOMATIC} if you want the image to look
	 * correct, but if dimension-fitting is the #1 priority regardless of
	 * how it makes the image look, that is what this mode is for.</p>
	 */
	FIT_EXACT,
	/**
	 * Used to indicate that the scaling implementation should calculate
	 * dimensions for the largest image that fit within the bounding box,
	 * without cropping or distortion, retaining the original proportions.
	 */
	BEST_FIT_BOTH,
	/**
	 * Used to indicate that the scaling implementation should calculate
	 * dimensions for the resultant image that best-fit within the given
	 * width, regardless of the orientation of the image.
	 */
	FIT_TO_WIDTH,
	/**
	 * Used to indicate that the scaling implementation should calculate
	 * dimensions for the resultant image that best-fit within the given
	 * height, regardless of the orientation of the image.
	 */
        FIT_TO_HEIGHT,
        /**
         * Used to indicate that the scaling implementation should calculate
         * dimensions for the resultant image that best-fit within the given
         * height and width, and then crop it to fit within the bounding box.
         */
        CROP;
    }

    /**
     * Used to define the different types of rotations that can be applied to an
     * image during a resize operation.
     */
    public static enum Rotation {

	/**
	 * 90-degree, clockwise rotation (to the right). This is equivalent to a
	 * quarter-turn of the image to the right; moving the picture on to its
	 * right side.
	 */
	CW_90,
	/**
	 * 180-degree, clockwise rotation (to the right). This is equivalent to
	 * 1 half-turn of the image to the right; rotating the picture around
	 * until it is upside down from the original position.
	 */
	CW_180,
	/**
	 * 270-degree, clockwise rotation (to the right). This is equivalent to
	 * a quarter-turn of the image to the left; moving the picture on to its
	 * left side.
	 */
	CW_270,
	/**
	 * Flip the image horizontally by reflecting it around the y axis.
	 * <p>
	 * This is not a standard rotation around a center point, but instead
	 * creates the mirrored reflection of the image horizontally.
	 * </p><p>
	 * More specifically, the vertical orientation of the image stays the
	 * same (the top stays on top, and the bottom on bottom), but the right
	 * and left sides flip. This is different than a standard rotation where
	 * the top and bottom would also have been flipped.</p>
	 */
	FLIP_HORZ,
	/**
	 * Flip the image vertically by reflecting it around the x axis.
	 * <p>
	 * This is not a standard rotation around a center point, but instead
	 * creates the mirrored reflection of the image vertically.
	 * </p><p>
	 * More specifically, the horizontal orientation of the image stays the
	 * same (the left stays on the left and the right stays on the right),
	 * but the top and bottom sides flip. This is different than a standard
	 * rotation where the left and right would also have been flipped.</p>
	 */
	FLIP_VERT;
    }

    /**
     * Threshold (in pixels) at which point the scaling operation using the
     * {@link Method#AUTOMATIC} method will decide if a {@link Method#BALANCED}
     * method will be used (if smaller than or equal to threshold) or a
     * {@link Method#SPEED} method will be used (if larger than threshold).
     * <p>
     * The bigger the image is being scaled to, the less noticeable degradations
     * in the image becomes and the faster algorithms can be selected.
     * </p>
     * <p>
     * The value of this threshold (1600) was chosen after visual, by-hand, A/B
     * testing between different types of images scaled with this library; both
     * photographs and screenshots. It was determined that images below this
     * size need to use a {@link Method#BALANCED} scale method to look decent in
     * most all cases while using the faster {@link Method#SPEED} method for
     * images bigger than this threshold showed no noticeable degradation over a
     * <code>BALANCED</code> scale.
     * </p>
     */
    static final int THRESHOLD_BALANCED_SPEED = 1600;

    /**
     * Threshold (in pixels) at which point the scaling operation using the
     * {@link Method#AUTOMATIC} method will decide if a {@link Method#QUALITY}
     * method will be used (if smaller than or equal to threshold) or a
     * {@link Method#BALANCED} method will be used (if larger than threshold).
     * <p>
     * The bigger the image is being scaled to, the less noticeable degradations
     * in the image becomes and the faster algorithms can be selected.
     * </p>
     * <p>
     * The value of this threshold (800) was chosen after visual, by-hand, A/B
     * testing between different types of images scaled with this library; both
     * photographs and screenshots. It was determined that images below this
     * size need to use a {@link Method#QUALITY} scale method to look decent in
     * most all cases while using the faster {@link Method#BALANCED} method for
     * images bigger than this threshold showed no noticeable degradation over a
     * <code>QUALITY</code> scale.
     * </p>
     */
    static final int THRESHOLD_QUALITY_BALANCED = 800;

    /**
     * Used to apply, in the order given, 1 or more {@link BufferedImageOp}s to
     * a given {@link BufferedImage} and return the result.
     * <p>
     * <strong>Feature</strong>: This implementation works around <a
     * href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4965606">a
     * decade-old JDK bug</a> that can cause a {@link RasterFormatException}
     * when applying a perfectly valid {@link BufferedImageOp}s to images.
     * </p><p>
     * <strong>Feature</strong>: This implementation also works around
     * {@link BufferedImageOp}s failing to apply and throwing
     * {@link ImagingOpException}s when run against a <code>src</code> image
     * type that is poorly supported. Unfortunately using {@link ImageIO} and
     * standard Java methods to load images provides no consistency in getting
     * images in well-supported formats. This method automatically accounts and
     * corrects for all those problems (if necessary).
     * </p><p>
     * It is recommended you always use this method to apply any
     * {@link BufferedImageOp}s instead of relying on directly using the
     * {@link BufferedImageOp#filter(BufferedImage, BufferedImage)} method.
     * </p><p>
     * <strong>Performance</strong>: Not all {@link BufferedImageOp}s are
     * hardware accelerated operations, but many of the most popular (like
     * {@link ConvolveOp}) are. For more information on if your image op is
     * hardware accelerated or not, check the source code of the underlying JDK
     * class that actually executes the Op code, <a href=
     * "http://www.docjar.com/html/api/sun/awt/image/ImagingLib.java.html"
     * >sun.awt.image.ImagingLib</a>.
     * </p><p>
     * <strong>TIP</strong>: This operation leaves the original <code>src</code>
     * image unmodified. If the caller is done with the <code>src</code> image
     * after getting the result of this operation, remember to call
     * {@link BufferedImage#flush()} on the <code>src</code> to free up native
     * resources and make it easier for the GC to collect the unused image.</p>
     *
     * @param src The image that will have the ops applied to it.
     * @param ops <code>1</code> or more ops to apply to the image.
     *
     * @return a new {@link BufferedImage} that represents the <code>src</code>
     * with all the given operations applied to it.
     *
     * @throws IllegalArgumentException if <code>src</code> is
     * <code>null</code>.
     * @throws IllegalArgumentException if <code>ops</code> is <code>null</code>
     * or empty.
     * @throws ImagingOpException if one of the given {@link BufferedImageOp}s
     * fails to apply. These exceptions bubble up from the inside of most of the
     * {@link BufferedImageOp} implementations and are explicitly defined on the
     * Pictura API to make it easier for callers to catch the exception (if they
     * are passing along optional ops to be applied). Pictura takes detailed
     * steps to avoid the most common pitfalls that will cause
     * {@link BufferedImageOp}s to fail, even when using straight forward
     * JDK-image operations.
     */
    public static BufferedImage apply(BufferedImage src, BufferedImageOp... ops)
	    throws IllegalArgumentException, ImagingOpException {
	if (src == null) {
	    throw new IllegalArgumentException("src cannot be null");
	}
	if (ops == null || ops.length == 0) {
	    throw new IllegalArgumentException("ops cannot be null or empty");
	}

	int type = src.getType();

	/*
	 * Ensure the src image is in the best supported image type before we
	 * continue, otherwise it is possible our calls below to getBounds2D and
	 * certainly filter(...) may fail if not.
	 * 
	 * Java2D makes an attempt at applying most BufferedImageOps using
	 * hardware acceleration via the ImagingLib internal library.
	 * 
	 * Unfortunately may of the BufferedImageOp are written to simply fail
	 * with an ImagingOpException if the operation cannot be applied with no
	 * additional information about what went wrong or attempts at
	 * re-applying it in different ways.
	 * 
	 * This is assuming the failing BufferedImageOp even returns a null
	 * image after failing to apply; some simply return a corrupted/black
	 * image that result in no exception and it is up to the user to
	 * discover this.
	 * 
	 * In internal testing, EVERY failure I've ever seen was the result of
	 * the source image being in a poorly-supported BufferedImage Type like
	 * BGR or ABGR (even though it was loaded with ImageIO).
	 * 
	 * To avoid this nasty/stupid surprise with BufferedImageOps, we always
	 * ensure that the src image starts in an optimally supported format
	 * before we try and apply the filter.
	 */
	if (!(type == BufferedImage.TYPE_INT_RGB || type == BufferedImage.TYPE_INT_ARGB)) {
	    src = copyToOptimalImage(src);
	}

	boolean hasReassignedSrc = false;

	for (BufferedImageOp op : ops) {
	    // Skip null ops instead of throwing an exception.
	    if (op == null) {
		continue;
	    }

	    /*
	     * Must use op.getBounds instead of src.getWidth and src.getHeight
	     * because we are trying to create an image big enough to hold the
	     * result of this operation (which may be to scale the image
	     * smaller), in that case the bounds reported by this op and the
	     * bounds reported by the source image will be different.
	     */
	    Rectangle2D resultBounds = op.getBounds2D(src);

	    // Watch out for flaky/misbehaving ops that fail to work right.
	    if (resultBounds == null) {
		throw new ImagingOpException(
			"BufferedImageOp ["
			+ op.toString()
			+ "] getBounds2D(src) returned null bounds for the target image; this should not happen and indicates a problem with application of this type of op.");
	    }

	    /*
	     * We must manually create the target image; we cannot rely on the
	     * null-destination filter() method to create a valid destination
	     * for us thanks to this JDK bug that has been filed for almost a
	     * decade:
	     * http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4965606
	     */
	    BufferedImage dest = createOptimalImage(src,
		    (int) Math.round(resultBounds.getWidth()),
		    (int) Math.round(resultBounds.getHeight()));

	    // Perform the operation, update our result to return.
	    BufferedImage result = op.filter(src, dest);

	    /*
	     * Flush the 'src' image ONLY IF it is one of our interim temporary
	     * images being used when applying 2 or more operations back to
	     * back. We never want to flush the original image passed in.
	     */
	    if (hasReassignedSrc) {
		src.flush();
	    }

	    /*
	     * Incase there are more operations to perform, update what we
	     * consider the 'src' reference to our last result so on the next
	     * iteration the next op is applied to this result and not back
	     * against the original src passed in.
	     */
	    src = result;

	    /*
	     * Keep track of when we re-assign 'src' to an interim temporary
	     * image, so we know when we can explicitly flush it and clean up
	     * references on future iterations.
	     */
	    hasReassignedSrc = true;
	}
	return src;
    }

    /**
     * Used to remove the outer border of the given <code>src</code> image and 
     * apply any optional {@link BufferedImageOp}s to it before returning the 
     * result.
     * <p>
     * <strong>TIP</strong>: This operation leaves the original <code>src</code>
     * image unmodified. If the caller is done with the <code>src</code> image
     * after getting the result of this operation, remember to call
     * {@link BufferedImage#flush()} on the <code>src</code> to free up native
     * resources and make it easier for the GC to collect the unused image.</p>
     *
     * @param src The image to crop.
     * @param tol The color tolerance (0..1) to detect the border width.
     * @param ops <code>0</code> or more ops to apply to the image. If
     * <code>null</code> or empty then <code>src</code> is return unmodified.
     *
     * @return a new {@link BufferedImage} representing the cropped region of
     * the <code>src</code> image with any optional operations applied to it.
     *
     * @throws IllegalArgumentException if <code>src</code> is
     * <code>null</code>.
     * @throws ImagingOpException if one of the given {@link BufferedImageOp}s
     * fails to apply. These exceptions bubble up from the inside of most of the
     * {@link BufferedImageOp} implementations and are explicitly defined on the
     * Pictura API to make it easier for callers to catch the exception (if they
     * are passing along optional ops to be applied). Pictura takes detailed
     * steps to avoid the most common pitfalls that will cause
     * {@link BufferedImageOp}s to fail, even when using straight forward
     * JDK-image operations.     
     */
    public static BufferedImage trim(BufferedImage src, float tol, BufferedImageOp... ops)
	    throws IllegalArgumentException, ImagingOpException {

	if (src == null) {
	    throw new IllegalArgumentException("src cannot be null");
	}
	if (tol < 0f || tol > 1f) {
	    throw new IllegalArgumentException("Invalid tolerance: [" + tol + "]");
	}

	// The pixel of the upper left corner is our base color
	int baseColor = src.getRGB(0, 0);

	int w = src.getWidth();
	int h = src.getHeight();

	int x1 = -1, y1 = -1, x2 = -1, y2 = -1;

	for (int x = 0; x < w; x++) {
	    for (int y = 0; y < h; y++) {
		if (x1 == -1 && y1 == -1
			&& !colorWithinTolerance(baseColor, src.getRGB(x, y), tol)) {
		    x1 = x;
		    y1 = y;
		    break;
		}
	    }
	}

	x1 = Math.max(x1, 0);
	y1 = Math.max(y1, 0);

	for (int x = w - 1; x > x1; x--) {
	    for (int y = h - 1; y > y1; y--) {
		if (x2 == -1 && y2 == -1
			&& !colorWithinTolerance(baseColor, src.getRGB(x, y), tol)) {
		    x2 = x;
		    y2 = y;
		    break;
		}
	    }
	}

	x2 = x2 > -1 ? Math.min(x2, w - 1) : w - 1;
	y2 = y2 > -1 ? Math.min(y2, h - 1) : h - 1;

	int x3 = -1, y3 = -1, x4 = -1, y4 = -1;

	for (int x = w - 1; x > x1; x--) {
	    for (int y = 0; y < y2; y++) {
		if (x3 == -1 && y3 == -1
			&& !colorWithinTolerance(baseColor, src.getRGB(x, y), tol)) {
		    x3 = x;
		    y3 = y;
		    break;
		}
	    }
	}

	x3 = x3 > -1 ? Math.min(x3, w - 1) : w - 1;
	y3 = Math.max(y3, 0);

	for (int x = 0; x < x2; x++) {
	    for (int y = h - 1; y > y1; y--) {
		if (x4 == -1 && y4 == -1
			&& !colorWithinTolerance(baseColor, src.getRGB(x, y), tol)) {
		    x4 = x;
		    y4 = y;
		    break;
		}
	    }
	}

	x4 = Math.max(x4, 0);
	y4 = y4 > -1 ? Math.min(y4, h - 1) : h - 1;

	int x01 = Math.min(x1, x4), y01 = Math.min(y1, y3);
	int x11 = Math.max(x2, x3), y11 = Math.max(y2, y4);

	int xd = x11 - x01, yd = y11 - y01;

	BufferedImage result = createOptimalImage(src, xd, yd);

	Graphics g = result.getGraphics();
	g.drawImage(src.getSubimage(x01, y01, xd, yd), 0, 0, null);
	g.dispose();

	// Apply any optional operations (if specified).
	if (ops != null && ops.length > 0) {
	    result = apply(result, ops);
	}

	return result;
    }

    private static boolean colorWithinTolerance(int a, int b, double tol) {
	int distance = 0;
	for (int i = 0; i < 32; i += 8) {
	    distance += Math.pow(((a >> i) & 0xff) - ((b >> i) & 0xff), 2);
	}
	return distance <= tol * 260100;
    }

    /**
     * Used to crop the given <code>src</code> image and apply any optional
     * {@link BufferedImageOp}s to it before returning the result.
     * <p>
     * <strong>TIP</strong>: This operation leaves the original <code>src</code>
     * image unmodified. If the caller is done with the <code>src</code> image
     * after getting the result of this operation, remember to call
     * {@link BufferedImage#flush()} on the <code>src</code> to free up native
     * resources and make it easier for the GC to collect the unused image.</p>
     *
     * @param src The image to crop.
     * @param x The x-coordinate of the top-left corner of the bounding box used
     * for cropping.
     * @param y The y-coordinate of the top-left corner of the bounding box used
     * for cropping.
     * @param width The width of the bounding cropping box.
     * @param height The height of the bounding cropping box.
     * @param ops <code>0</code> or more ops to apply to the image. If
     * <code>null</code> or empty then <code>src</code> is return unmodified.
     *
     * @return a new {@link BufferedImage} representing the cropped region of
     * the <code>src</code> image with any optional operations applied to it.
     *
     * @throws IllegalArgumentException if <code>src</code> is
     * <code>null</code>.
     * @throws IllegalArgumentException if any coordinates of the bounding crop
     * box is invalid within the bounds of the <code>src</code> image (e.g.
     * negative or too big).
     * @throws ImagingOpException if one of the given {@link BufferedImageOp}s
     * fails to apply. These exceptions bubble up from the inside of most of the
     * {@link BufferedImageOp} implementations and are explicitly defined on the
     * Pictura API to make it easier for callers to catch the exception (if they
     * are passing along optional ops to be applied). Pictura takes detailed
     * steps to avoid the most common pitfalls that will cause
     * {@link BufferedImageOp}s to fail, even when using straight forward
     * JDK-image operations.
     */
    public static BufferedImage crop(BufferedImage src, int x, int y,
	    int width, int height, BufferedImageOp... ops)
	    throws IllegalArgumentException, ImagingOpException {

	if (src == null) {
	    throw new IllegalArgumentException("src cannot be null");
	}
	if (x < 0 || y < 0 || width < 0 || height < 0) {
	    throw new IllegalArgumentException("Invalid crop bounds: x [" + x
		    + "], y [" + y + "], width [" + width + "] and height ["
		    + height + "] must all be >= 0");
	}

	int srcWidth = src.getWidth();
	int srcHeight = src.getHeight();

	if ((x + width) > srcWidth) {
	    throw new IllegalArgumentException(
		    "Invalid crop bounds: x + width [" + (x + width)
		    + "] must be <= src.getWidth() [" + srcWidth + "]");
	}
	if ((y + height) > srcHeight) {
	    throw new IllegalArgumentException(
		    "Invalid crop bounds: y + height [" + (y + height)
		    + "] must be <= src.getHeight() [" + srcHeight
		    + "]");
	}

	// Create a target image of an optimal type to render into.
	BufferedImage result = createOptimalImage(src, width, height);
	Graphics g = result.getGraphics();

	/*
	 * Render the region specified by our crop bounds from the src image
	 * directly into our result image (which is the exact size of the crop
	 * region).
	 */
	g.drawImage(src, 0, 0, width, height, x, y, (x + width), (y + height),
		null);
	g.dispose();

	// Apply any optional operations (if specified).
	if (ops != null && ops.length > 0) {
	    result = apply(result, ops);
	}

	return result;
    }

    /**
     * Resize a given image (maintaining its original proportion) to the target
     * width and height (or fitting the image to the given WIDTH or HEIGHT
     * explicitly, depending on the {@link Mode} specified) using the given
     * scaling method and apply the given {@link BufferedImageOp}s (if any) to
     * the result before returning it.
     * <p>
     * <strong>TIP</strong>: See the class description to understand how this
     * class handles recalculation of the <code>targetWidth</code> or
     * <code>targetHeight</code> depending on the image's orientation in order
     * to maintain the original proportion.
     * </p><p>
     * <strong>TIP</strong>: This operation leaves the original <code>src</code>
     * image unmodified. If the caller is done with the <code>src</code> image
     * after getting the result of this operation, remember to call
     * {@link BufferedImage#flush()} on the <code>src</code> to free up native
     * resources and make it easier for the GC to collect the unused image.</p>
     *
     * @param src The image that will be scaled.
     * @param scalingMethod The method used for scaling the image; preferring
     * speed to quality or a balance of both.
     * @param resizeMode Used to indicate how Pictura should calculate the final
     * target size for the image, either fitting the image to the given width
     * ({@link Mode#FIT_TO_WIDTH}) or fitting the image to the given height
     * ({@link Mode#FIT_TO_HEIGHT}). If {@link Mode#AUTOMATIC} is passed in,
     * Pictura will calculate proportional dimensions for the scaled image based
     * on its orientation (landscape, square or portrait). Unless you have very
     * specific size requirements, most of the time you just want to use
     * {@link Mode#AUTOMATIC} to "do the right thing".
     * @param targetWidth The target width that you wish the image to have.
     * @param targetHeight The target height that you wish the image to have.
     * @param ops <code>0</code> or more optional image operations (e.g.
     * sharpen, blur, etc.) that can be applied to the final result before
     * returning the image.
     *
     * @return a new {@link BufferedImage} representing the scaled
     * <code>src</code> image.
     *
     * @throws IllegalArgumentException if <code>src</code> is
     * <code>null</code>.
     * @throws IllegalArgumentException if <code>scalingMethod</code> is
     * <code>null</code>.
     * @throws IllegalArgumentException if <code>resizeMode</code> is
     * <code>null</code>.
     * @throws IllegalArgumentException if <code>targetWidth</code> is &lt; 0 or
     * if <code>targetHeight</code> is &lt; 0.
     * @throws ImagingOpException if one of the given {@link BufferedImageOp}s
     * fails to apply. These exceptions bubble up from the inside of most of the
     * {@link BufferedImageOp} implementations and are explicitly defined on the
     * Pictura API to make it easier for callers to catch the exception (if they
     * are passing along optional ops to be applied). Pictura takes detailed
     * steps to avoid the most common pitfalls that will cause
     * {@link BufferedImageOp}s to fail, even when using straight forward
     * JDK-image operations.
     *
     * @see Method
     * @see Mode
     */
    public static BufferedImage resize(BufferedImage src, Method scalingMethod,
	    Mode resizeMode, int targetWidth, int targetHeight,
	    BufferedImageOp... ops) throws IllegalArgumentException,
	    ImagingOpException {

	if (src == null) {
	    throw new IllegalArgumentException("src cannot be null");
	}
	if (targetWidth < 0) {
	    throw new IllegalArgumentException("targetWidth must be >= 0");
	}
	if (targetHeight < 0) {
	    throw new IllegalArgumentException("targetHeight must be >= 0");
	}
	if (scalingMethod == null) {
	    throw new IllegalArgumentException(
		    "scalingMethod cannot be null. A good default value is Method.AUTOMATIC.");
	}
	if (resizeMode == null) {
	    throw new IllegalArgumentException(
		    "resizeMode cannot be null. A good default value is Mode.AUTOMATIC.");
	}

	BufferedImage result = null;

	int currentWidth = src.getWidth();
	int currentHeight = src.getHeight();

	// <= 1 is a square or landscape-oriented image, > 1 is a portrait.
	float ratio = ((float) currentHeight / (float) currentWidth);

        /*
	 * First determine if ANY size calculation needs to be done, in the case
	 * of FIT_EXACT, ignore image proportions and orientation and just use
	 * what the user sent in, otherwise the proportion of the picture must
	 * be honored.
	 * 
	 * The way that is done is to figure out if the image is in a
	 * LANDSCAPE/SQUARE or PORTRAIT orientation and depending on its
	 * orientation, use the primary dimension (width for LANDSCAPE/SQUARE
	 * and height for PORTRAIT) to recalculate the alternative (height and
	 * width respectively) value that adheres to the existing ratio.
	 * 
	 * This helps make life easier for the caller as they don't need to
	 * pre-compute proportional dimensions before calling the API, they can
	 * just specify the dimensions they would like the image to roughly fit
	 * within and it will do the right thing without mangling the result.
         */
        if (resizeMode == Mode.BEST_FIT_BOTH) {
            float requestedHeightScaling = ((float) targetHeight / (float) currentHeight);
            float requestedWidthScaling = ((float) targetWidth / (float) currentWidth);
            float actualScaling = Math.min(requestedHeightScaling, requestedWidthScaling);

            targetHeight = Math.round((float) currentHeight * actualScaling);
            targetWidth = Math.round((float) currentWidth * actualScaling);

            if (targetHeight == currentHeight && targetWidth == currentWidth) {
                return src;
            }
        } else if (resizeMode != Mode.FIT_EXACT) {
            if ((ratio <= 1 && resizeMode == Mode.AUTOMATIC) || (resizeMode == Mode.FIT_TO_WIDTH)) {
                // First make sure we need to do any work in the first place
                if (targetWidth == currentWidth) {
                    return src;
                }

                /*
		 * Landscape or Square Orientation: Ignore the given height and
		 * re-calculate a proportionally correct value based on the
		 * targetWidth.
                 */
                targetHeight = Math.round((float) targetWidth * ratio);
            } else if (resizeMode == Mode.CROP) {
                
                // https://github.com/leon/imgscalr/commit/c71bbc991481c43aed4b0e56a06bd8553e62cd72
                
                // If already right size return
                if (targetWidth == currentWidth && targetHeight == currentHeight) {
                    return src;
                }

                int originalTargetWidth = targetWidth;
                int originalTargetHeight = targetHeight;

                // Calculate ratio that will fit within the targetWidth and height
                ratio = Math.max((float) targetWidth / currentWidth, (float) targetHeight / currentHeight);

                targetWidth = Math.round((float) currentWidth * ratio);
                targetHeight = Math.round((float) currentHeight * ratio);

                // Calculate the offset for the crop
                int xOffset = (int) ((targetWidth - originalTargetWidth) / 2D);
                int yOffset = (int) ((targetHeight - originalTargetHeight) / 2D);

                // If the calculated size is bigger than what was sent in, return what was sent in instead.
                targetWidth = (int) Math.ceil(targetWidth > originalTargetWidth ? originalTargetWidth : targetWidth);
                targetHeight = (int) Math.ceil(targetHeight > originalTargetHeight ? originalTargetHeight : targetHeight);

                // Crop to fit within the target height and width
                src = crop(src, xOffset, yOffset, targetWidth, targetHeight);
            } else {
                // First make sure we need to do any work in the first place
                if (targetHeight == currentHeight) {
                    return src;
                }

                /*
		 * Portrait Orientation: Ignore the given width and re-calculate
		 * a proportionally correct value based on the targetHeight.
                 */
                targetWidth = Math.round((float) targetHeight / ratio);
            }
        }

        // If AUTOMATIC was specified, determine the real scaling method.
        if (scalingMethod == Method.AUTOMATIC) {
            scalingMethod = determineScalingMethod(targetWidth, targetHeight,
                    ratio);
        }

        // Now we scale the image
        if (scalingMethod == Method.SPEED) {
            result = scaleImage(src, targetWidth, targetHeight,
                    RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);
        } else if (scalingMethod == Method.BALANCED) {
            result = scaleImage(src, targetWidth, targetHeight,
                    RenderingHints.VALUE_INTERPOLATION_BILINEAR);
        } else if (scalingMethod == Method.QUALITY
                || scalingMethod == Method.ULTRA_QUALITY) {
            /*
	     * If we are scaling up (in either width or height - since we know
	     * the image will stay proportional we just check if either are
	     * being scaled up), directly using a single BICUBIC will give us
	     * better results then using Chris Campbell's incremental scaling
	     * operation (and take a lot less time).
	     * 
	     * If we are scaling down, we must use the incremental scaling
	     * algorithm for the best result.
             */
            if (targetWidth > currentWidth || targetHeight > currentHeight) {
                /*
		 * BILINEAR and BICUBIC look similar the smaller the scale jump
		 * upwards is, if the scale is larger BICUBIC looks sharper and
		 * less fuzzy. But most importantly we have to use BICUBIC to
		 * match the contract of the QUALITY rendering scalingMethod.
		 * This note is just here for anyone reading the code and
		 * wondering how they can speed their own calls up.
                 */
                result = scaleImage(src, targetWidth, targetHeight,
                        RenderingHints.VALUE_INTERPOLATION_BICUBIC);
            } else {
                /*
		 * Originally we wanted to use BILINEAR interpolation here
		 * because it takes 1/3rd the time that the BICUBIC
		 * interpolation does, however, when scaling large images down
		 * to most sizes bigger than a thumbnail we witnessed noticeable
		 * "softening" in the resultant image with BILINEAR that would
		 * be unexpectedly annoying to a user expecting a "QUALITY"
		 * scale of their original image. Instead BICUBIC was chosen to
		 * honor the contract of a QUALITY scale of the original image.
                 */
                result = scaleImageIncrementally(src, targetWidth,
                        targetHeight, scalingMethod,
                        RenderingHints.VALUE_INTERPOLATION_BICUBIC);
            }
        }

        // Apply any optional operations (if specified).
        if (ops != null && ops.length > 0) {
            result = apply(result, ops);
        }

        return result;
    }

    /**
     * Used to apply a {@link Rotation} and then <code>0</code> or more
     * {@link BufferedImageOp}s to a given image and return the result.
     * <p>
     * <strong>TIP</strong>: This operation leaves the original <code>src</code>
     * image unmodified. If the caller is done with the <code>src</code> image
     * after getting the result of this operation, remember to call
     * {@link BufferedImage#flush()} on the <code>src</code> to free up native
     * resources and make it easier for the GC to collect the unused image.</p>
     *
     * @param src The image that will have the rotation applied to it.
     * @param rotation The rotation that will be applied to the image.
     * @param ops Zero or more optional image operations (e.g. sharpen, blur,
     * etc.) that can be applied to the final result before returning the image.
     *
     * @return a new {@link BufferedImage} representing <code>src</code> rotated
     * by the given amount and any optional ops applied to it.
     *
     * @throws IllegalArgumentException if <code>src</code> is
     * <code>null</code>.
     * @throws IllegalArgumentException if <code>rotation</code> is
     * <code>null</code>.
     * @throws ImagingOpException if one of the given {@link BufferedImageOp}s
     * fails to apply. These exceptions bubble up from the inside of most of the
     * {@link BufferedImageOp} implementations and are explicitly defined on the
     * Pictura API to make it easier for callers to catch the exception (if they
     * are passing along optional ops to be applied). Pictura takes detailed
     * steps to avoid the most common pitfalls that will cause
     * {@link BufferedImageOp}s to fail, even when using straight forward
     * JDK-image operations.
     *
     * @see Rotation
     */
    public static BufferedImage rotate(BufferedImage src, Rotation rotation,
	    BufferedImageOp... ops) throws IllegalArgumentException,
	    ImagingOpException {

	if (src == null) {
	    throw new IllegalArgumentException("src cannot be null");
	}
	if (rotation == null) {
	    throw new IllegalArgumentException("rotation cannot be null");
	}

	/*
	 * Setup the default width/height values from our image.
	 * 
	 * In the case of a 90 or 270 (-90) degree rotation, these two values
	 * flip-flop and we will correct those cases down below in the switch
	 * statement.
	 */
	int newWidth = src.getWidth();
	int newHeight = src.getHeight();

	/*
	 * We create a transform per operation request as (oddly enough) it ends
	 * up being faster for the VM to create, use and destroy these instances
	 * than it is to re-use a single AffineTransform per-thread via the
	 * AffineTransform.setTo(...) methods which was my first choice (less
	 * object creation); after benchmarking this explicit case and looking
	 * at just how much code gets run inside of setTo() I opted for a new AT
	 * for every rotation.
	 * 
	 * Besides the performance win, trying to safely reuse AffineTransforms
	 * via setTo(...) would have required ThreadLocal instances to avoid
	 * race conditions where two or more resize threads are manipulating the
	 * same transform before applying it.
	 * 
	 * Misusing ThreadLocals are one of the #1 reasons for memory leaks in
	 * server applications and since we have no nice way to hook into the
	 * init/destroy Servlet cycle or any other initialization cycle for this
	 * library to automatically call ThreadLocal.remove() to avoid the
	 * memory leak, it would have made using this library *safely* on the
	 * server side much harder.
	 * 
	 * So we opt for creating individual transforms per rotation op and let
	 * the VM clean them up in a GC. I only clarify all this reasoning here
	 * for anyone else reading this code and being tempted to reuse the AT
	 * instances of performance gains; there aren't any AND you get a lot of
	 * pain along with it.
	 */
	AffineTransform tx = new AffineTransform();

	switch (rotation) {
	    case CW_90:
		/*
		 * A 90 or -90 degree rotation will cause the height and width to
		 * flip-flop from the original image to the rotated one.
		 */
		newWidth = src.getHeight();
		newHeight = src.getWidth();

		// Reminder: newWidth == result.getHeight() at this point
		tx.translate(newWidth, 0);
                tx.rotate(Math.toRadians(90));
		break;

            case CW_180:
		tx.translate(newWidth, newHeight);
                tx.rotate(Math.toRadians(180));
		break;
                
	    case CW_270:
		/*
		 * A 90 or -90 degree rotation will cause the height and width to
		 * flip-flop from the original image to the rotated one.
		 */
		newWidth = src.getHeight();
		newHeight = src.getWidth();

		// Reminder: newHeight == result.getWidth() at this point
		tx.translate(0, newHeight);
                tx.rotate(Math.toRadians(-90));
		break;

	    case FLIP_HORZ:
		tx.translate(newWidth, 0);
		tx.scale(-1.0, 1.0);
		break;

	    case FLIP_VERT:
		tx.translate(0, newHeight);
		tx.scale(1.0, -1.0);
		break;
	}

	// Create our target image we will render the rotated result to.
	BufferedImage result = createOptimalImage(src, newWidth, newHeight);
	Graphics2D g2d = result.createGraphics();

	/*
	 * Render the resultant image to our new rotatedImage buffer, applying
	 * the AffineTransform that we calculated above during rendering so the
	 * pixels from the old position are transposed to the new positions in
	 * the resulting image correctly.
	 */
	g2d.drawImage(src, tx, null);
	g2d.dispose();

	// Apply any optional operations (if specified).
	if (ops != null && ops.length > 0) {
	    result = apply(result, ops);
	}

	return result;
    }

    /**
     * Used to apply padding around the edges of an image using the given color
     * to fill the extra padded space and then return the result. {@link Color}s
     * using an alpha channel (i.e. transparency) are supported.
     * <p>
     * The amount of <code>padding</code> specified is applied to all sides;
     * more specifically, a <code>padding</code> of <code>2</code> would add 2
     * extra pixels of space (filled by the given <code>color</code>) on the
     * top, bottom, left and right sides of the resulting image causing the
     * result to be 4 pixels wider and 4 pixels taller than the <code>src</code>
     * image.
     * </p>
     * <p>
     * <strong>TIP</strong>: This operation leaves the original <code>src</code>
     * image unmodified. If the caller is done with the <code>src</code> image
     * after getting the result of this operation, remember to call
     * {@link BufferedImage#flush()} on the <code>src</code> to free up native
     * resources and make it easier for the GC to collect the unused image.
     * </p>
     * @param src The image the padding will be added to.
     * @param padding The number of pixels of padding to add to each side in the
     * resulting image. If this value is <code>0</code> then <code>src</code> is
     * returned unmodified.
     * @param color The color to fill the padded space with. {@link Color}s
     * using an alpha channel (i.e. transparency) are supported.
     * @param ops <code>0</code> or more ops to apply to the image. If
     * <code>null</code> or empty then <code>src</code> is return unmodified.
     *
     * @return a new {@link BufferedImage} representing <code>src</code> with
     * the given padding applied to it.
     *
     * @throws IllegalArgumentException if <code>src</code> is
     * <code>null</code>.
     * @throws IllegalArgumentException if <code>padding</code> is &lt;
     * <code>1</code>.
     * @throws IllegalArgumentException if <code>color</code> is
     * <code>null</code>.
     * @throws ImagingOpException if one of the given {@link BufferedImageOp}s
     * fails to apply. These exceptions bubble up from the inside of most of the
     * {@link BufferedImageOp} implementations and are explicitly defined on the
     * imgscalr API to make it easier for callers to catch the exception (if
     * they are passing along optional ops to be applied). imgscalr takes
     * detailed steps to avoid the most common pitfalls that will cause
     * {@link BufferedImageOp}s to fail, even when using straight forward
     * JDK-image operations.
     */
    public static BufferedImage pad(BufferedImage src, int padding,
            Color color, BufferedImageOp... ops)
            throws IllegalArgumentException, ImagingOpException {

        if (src == null) {
            throw new IllegalArgumentException("src cannot be null");
        }
        if (padding < 1) {
            throw new IllegalArgumentException("padding [" + padding
                    + "] must be > 0");
        }
        if (color == null) {
            throw new IllegalArgumentException("color cannot be null");
        }

        int srcWidth = src.getWidth();
        int srcHeight = src.getHeight();

        /*
         * Double the padding to account for all sides of the image. More
         * specifically, if padding is "1" we add 2 pixels to width and 2 to
         * height, so we have 1 new pixel of padding all the way around our
         * image.
         */
        int sizeDiff = (padding * 2);
        int newWidth = srcWidth + sizeDiff;
        int newHeight = srcHeight + sizeDiff;

        boolean colorHasAlpha = (color.getAlpha() != 255);
        boolean imageHasAlpha = (src.getTransparency() != BufferedImage.OPAQUE);

        BufferedImage result;

        /*
         * We need to make sure our resulting image that we render into contains
         * alpha if either our original image OR the padding color we are using
         * contain it.
         */
        if (colorHasAlpha || imageHasAlpha) {
            result = new BufferedImage(newWidth, newHeight,
                    BufferedImage.TYPE_INT_ARGB);
        } else {
            result = new BufferedImage(newWidth, newHeight,
                    BufferedImage.TYPE_INT_RGB);
        }

        Graphics g = result.getGraphics();

        // "Clear" the background of the new image with our padding color first.
        g.setColor(color);
        g.fillRect(0, 0, newWidth, newHeight);

        // Draw the image into the center of the new padded image.
        g.drawImage(src, padding, padding, null);
        g.dispose();

        // Apply any optional operations (if specified).
        if (ops != null && ops.length > 0) {
            result = apply(result, ops);
        }

        return result;
    }
    
    /**
     * Used to create a {@link BufferedImage} with the given dimensions and the
     * most optimal RGB TYPE ( {@link BufferedImage#TYPE_INT_RGB} or
     * {@link BufferedImage#TYPE_INT_ARGB} ) capable of being rendered into from
     * the given <code>src</code>.
     * <p/>
     * This does not perform a copy of the image data from <code>src</code> into
     * the result image; see {@link #copyToOptimalImage(BufferedImage)} for
     * that.
     * <p/>
     * We force all rendering results into one of these two types, avoiding the
     * case where a source image is of an unsupported (or poorly supported)
     * format by Java2D causing the rendering result to end up looking terrible
     * (common with GIFs) or be totally corrupt (e.g. solid black image).
     * <p/>
     * Originally reported by Magnus Kvalheim from Movellas when scaling certain
     * GIF and PNG images.
     *
     * @param src The source image that will be analyzed to determine the most
     * optimal image type it can be rendered into.
     * @param width The width of the newly created resulting image.
     * @param height The height of the newly created resulting image.
     *
     * @return a new {@link BufferedImage} representing the most optimal target
     * image type that <code>src</code> can be rendered into.
     *
     * @throws IllegalArgumentException if <code>width</code> or
     * <code>height</code> are &lt; 0.
     *
     * @see <a
     * href="http://www.mail-archive.com/java2d-interest@capra.eng.sun.com/msg05621.html">How
     * Java2D handles poorly supported image types</a>
     * @see <a
     * href="http://code.google.com/p/java-image-scaling/source/browse/trunk/src/main/java/com/mortennobel/imagescaling/MultiStepRescaleOp.java">Thanks
     * to Morten Nobel for implementation hint</a>
     */
    private static BufferedImage createOptimalImage(BufferedImage src,
	    int width, int height) throws IllegalArgumentException {
	if (width <= 0 || height <= 0) {
	    throw new IllegalArgumentException("width [" + width
		    + "] and height [" + height + "] must be >= 0");
	}
        
	return new BufferedImage(
		width,
		height,
		(src.getTransparency() == Transparency.OPAQUE ? BufferedImage.TYPE_INT_RGB
			: BufferedImage.TYPE_INT_ARGB));        
    }

    /**
     * Used to copy a {@link BufferedImage} from a non-optimal type into a new
     * {@link BufferedImage} instance of an optimal type (RGB or ARGB). If
     * <code>src</code> is already of an optimal type, then it is returned
     * unmodified.
     * <p/>
     * This method is meant to be used by any calling code (Pictura's or
     * otherwise) to convert any inbound image from a poorly supported image
     * type into the 2 most well-supported image types in Java2D (
     * {@link BufferedImage#TYPE_INT_RGB} or {@link BufferedImage#TYPE_INT_ARGB}
     * ) in order to ensure all subsequent graphics operations are performed as
     * efficiently and correctly as possible.
     * <p/>
     * When using Java2D to work with image types that are not well supported,
     * the results can be anything from exceptions bubbling up from the depths
     * of Java2D to images being completely corrupted and just returned as solid
     * black.
     *
     * @param src The image to copy (if necessary) into an optimally typed
     * {@link BufferedImage}.
     *
     * @return a representation of the <code>src</code> image in an optimally
     * typed {@link BufferedImage}, otherwise <code>src</code> if it was already
     * of an optimal type.
     *
     * @throws IllegalArgumentException if <code>src</code> is
     * <code>null</code>.
     */
    private static BufferedImage copyToOptimalImage(BufferedImage src)
	    throws IllegalArgumentException {
	if (src == null) {
	    throw new IllegalArgumentException("src cannot be null");
	}

	// Calculate the type depending on the presence of alpha.
	int type = (src.getTransparency() == Transparency.OPAQUE ? BufferedImage.TYPE_INT_RGB
		: BufferedImage.TYPE_INT_ARGB);
	BufferedImage result = new BufferedImage(src.getWidth(),
		src.getHeight(), type);
        
	// Render the src image into our new optimal source.
	Graphics g = result.getGraphics();
	g.drawImage(src, 0, 0, null);
	g.dispose();

	return result;
    }

    /**
     * Used to determine the scaling {@link Method} that is best suited for
     * scaling the image to the targeted dimensions.
     * <p/>
     * This method is intended to be used to select a specific scaling
     * {@link Method} when a {@link Method#AUTOMATIC} method is specified. This
     * method utilizes the {@link Pictura#THRESHOLD_QUALITY_BALANCED} and
     * {@link Pictura#THRESHOLD_BALANCED_SPEED} thresholds when selecting which
     * method should be used by comparing the primary dimension (width or
     * height) against the threshold and seeing where the image falls. The
     * primary dimension is determined by looking at the orientation of the
     * image: landscape or square images use their width and portrait-oriented
     * images use their height.
     *
     * @param targetWidth The target width for the scaled image.
     * @param targetHeight The target height for the scaled image.
     * @param ratio A height/width ratio used to determine the orientation of
     * the image so the primary dimension (width or height) can be selected to
     * test if it is greater than or less than a particular threshold.
     *
     * @return the fastest {@link Method} suited for scaling the image to the
     * specified dimensions while maintaining a good-looking result.
     */
    private static Method determineScalingMethod(int targetWidth,
	    int targetHeight, float ratio) {
	// Get the primary dimension based on the orientation of the image
	int length = (ratio <= 1 ? targetWidth : targetHeight);

	// Default to speed
	Method result = Method.SPEED;

	// Figure out which scalingMethod should be used
	if (length <= THRESHOLD_QUALITY_BALANCED) {
	    result = Method.QUALITY;
	} else if (length <= THRESHOLD_BALANCED_SPEED) {
	    result = Method.BALANCED;
	}

	return result;
    }

    /**
     * Used to implement a straight-forward image-scaling operation using Java
     * 2D.
     * <p/>
     * This method uses the Oracle-encouraged method of
     * <code>Graphics2D.drawImage(...)</code> to scale the given image with the
     * given interpolation hint.
     *
     * @param src The image that will be scaled.
     * @param targetWidth The target width for the scaled image.
     * @param targetHeight The target height for the scaled image.
     * @param interpolationHintValue The {@link RenderingHints} interpolation
     * value used to indicate the method that {@link Graphics2D} should use when
     * scaling the image.
     *
     * @return the result of scaling the original <code>src</code> to the given
     * dimensions using the given interpolation method.
     */
    private static BufferedImage scaleImage(BufferedImage src,
	    int targetWidth, int targetHeight, Object interpolationHintValue) {
	// Setup the rendering resources to match the source image's
	BufferedImage result = createOptimalImage(src, targetWidth,
		targetHeight);
	Graphics2D resultGraphics = result.createGraphics();

	// Scale the image to the new buffer using the specified rendering hint.
	resultGraphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION,
		interpolationHintValue);
	resultGraphics.drawImage(src, 0, 0, targetWidth, targetHeight, null);

	// Just to be clean, explicitly dispose our temporary graphics object
	resultGraphics.dispose();

	// Return the scaled image to the caller.
	return result;
    }

    /**
     * Used to implement Chris Campbell's incremental-scaling algorithm: 
     * <a href="http://today.java.net/pub/a/today/2007/04/03/perils-of-image-getscaledinstance.html">
     * http://today.java.net/pub/a/today/2007/04/03/perils-of-image-getscaledinstance.html</a>.
     * <p>
     * Modifications to the original algorithm are variable names and comments
     * added for clarity and the hard-coding of using BICUBIC interpolation as
     * well as the explicit "flush()" operation on the interim BufferedImage
     * instances to avoid resource leaking.
     * </p>
     * 
     * @param src The image that will be scaled.
     * @param targetWidth The target width for the scaled image.
     * @param targetHeight The target height for the scaled image.
     * @param scalingMethod The scaling method specified by the user (or
     * calculated by Pictura) to use for this incremental scaling operation.
     * @param interpolationHintValue The {@link RenderingHints} interpolation
     * value used to indicate the method that {@link Graphics2D} should use when
     * scaling the image.
     *
     * @return an image scaled to the given dimensions using the given rendering
     * hint.
     */
    private static BufferedImage scaleImageIncrementally(BufferedImage src,
	    int targetWidth, int targetHeight, Method scalingMethod,
	    Object interpolationHintValue) {

	boolean hasReassignedSrc = false;
	int currentWidth = src.getWidth();
	int currentHeight = src.getHeight();

	/*
	 * The original QUALITY mode, representing Chris Campbell's algorithm,
	 * is to step down by 1/2s every time when scaling the image
	 * incrementally. Users pointed out that using this method to scale
	 * images with noticeable straight lines left them really jagged in
	 * smaller thumbnail format.
	 * 
	 * After investigation it was discovered that scaling incrementally by
	 * smaller increments was the ONLY way to make the thumbnail sized
	 * images look less jagged and more accurate; almost matching the
	 * accuracy of Mac's built in thumbnail generation which is the highest
	 * quality resize I've come across (better than GIMP Lanczos3 and
	 * Windows 7).
	 * 
	 * A divisor of 7 was chose as using 5 still left some jaggedness in the
	 * image while a divisor of 8 or higher made the resulting thumbnail too
	 * soft; like our OP_ANTIALIAS convolve op had been forcibly applied to
	 * the result even if the user didn't want it that soft.
	 * 
	 * Using a divisor of 7 for the ULTRA_QUALITY seemed to be the sweet
	 * spot.
	 * 
	 * NOTE: Below when the actual fraction is used to calculate the small
	 * portion to subtract from the current dimension, this is a
	 * progressively smaller and smaller chunk. When the code was changed to
	 * do a linear reduction of the image of equal steps for each
	 * incremental resize (e.g. say 50px each time) the result was
	 * significantly worse than the progressive approach used below; even
	 * when a very high number of incremental steps (13) was tested.
	 */
	int fraction = (scalingMethod == Method.ULTRA_QUALITY ? 7 : 2);

	do {
	    int prevCurrentWidth = currentWidth;
	    int prevCurrentHeight = currentHeight;

	    /*
	     * If the current width is bigger than our target, cut it in half
	     * and sample again.
	     */
	    if (currentWidth > targetWidth) {
		currentWidth -= (currentWidth / fraction);

		/*
		 * If we cut the width too far it means we are on our last
		 * iteration. Just set it to the target width and finish up.
		 */
		if (currentWidth < targetWidth) {
		    currentWidth = targetWidth;
		}
	    }

	    /*
	     * If the current height is bigger than our target, cut it in half
	     * and sample again.
	     */
	    if (currentHeight > targetHeight) {
		currentHeight -= (currentHeight / fraction);

		/*
		 * If we cut the height too far it means we are on our last
		 * iteration. Just set it to the target height and finish up.
		 */
		if (currentHeight < targetHeight) {
		    currentHeight = targetHeight;
		}
	    }

	    /*
	     * Stop when we cannot incrementally step down anymore.
	     * 
	     * This used to use a || condition, but that would cause problems
	     * when using FIT_EXACT such that sometimes the width OR height
	     * would not change between iterations, but the other dimension
	     * would (e.g. resizing 500x500 to 500x250).
	     * 
	     * Now changing this to an && condition requires that both
	     * dimensions do not change between a resize iteration before we
	     * consider ourselves done.
	     */
	    if (prevCurrentWidth == currentWidth
		    && prevCurrentHeight == currentHeight) {
		break;
	    }

	    // Render the incremental scaled image.
	    BufferedImage incrementalImage = scaleImage(src, currentWidth,
		    currentHeight, interpolationHintValue);

	    /*
	     * Before re-assigning our interim (partially scaled)
	     * incrementalImage to be the new src image before we iterate around
	     * again to process it down further, we want to flush() the previous
	     * src image IF (and only IF) it was one of our own temporary
	     * BufferedImages created during this incremental down-sampling
	     * cycle. If it wasn't one of ours, then it was the original
	     * caller-supplied BufferedImage in which case we don't want to
	     * flush() it and just leave it alone.
	     */
	    if (hasReassignedSrc) {
		src.flush();
	    }

	    /*
	     * Now treat our incremental partially scaled image as the src image
	     * and cycle through our loop again to do another incremental
	     * scaling of it (if necessary).
	     */
	    src = incrementalImage;

	    /*
	     * Keep track of us re-assigning the original caller-supplied source
	     * image with one of our interim BufferedImages so we know when to
	     * explicitly flush the interim "src" on the next cycle through.
	     */
	    hasReassignedSrc = true;

	} while (currentWidth != targetWidth || currentHeight != targetHeight);

	/*
	 * Once the loop has exited, the src image argument is now our scaled
	 * result image that we want to return.
	 */
	return src;
    }

    static BufferedImage create(int width, int height, Color bgColor) {
	BufferedImage result = new BufferedImage(width, height, 
                BufferedImage.TYPE_INT_RGB);

	Graphics g = result.getGraphics();

	g.setColor(bgColor != null ? bgColor : Color.WHITE);
	g.fillRect(0, 0, width, height);

	return result;
    }

    /**
     * Converts the given image to an RGB image with the specified background
     * color in cases of alpha channel.
     *
     * @param src The source image to convert.
     * @param bgColor The default background color. If <code>null</code>
     * {@link Color#WHITE} is used as default color.
     *
     * @return The converted image.
     *
     * @throws IllegalArgumentException if the source image is
     * <code>null</code>.
     */
    static BufferedImage convertToRGBImage(BufferedImage src, Color bgColor)
	    throws IllegalArgumentException {
	if (src == null) {
	    throw new IllegalArgumentException("src cannot be null");
	}

	BufferedImage result = new BufferedImage(src.getWidth(),
		src.getHeight(), BufferedImage.TYPE_INT_RGB);

	// Render the src image into our new optimal source.
	Graphics g = result.getGraphics();
	g.drawImage(src, 0, 0, bgColor != null ? bgColor : Color.WHITE, null);
	g.dispose();

	return result;
    }

    static BufferedImage convertToBinaryImage(BufferedImage src) {
        
	BufferedImage out = new BufferedImage(src.getWidth(),
		src.getHeight(), BufferedImage.TYPE_BYTE_BINARY);

	Graphics2D g2 = out.createGraphics();
	g2.drawImage(src, 0, 0, null);
	g2.dispose();

	return out;
    }

    /**
     * Extracts a set of unique colors from the given image.
     *
     * @param img The image.
     *
     * @return A set of unique colors from the given image.
     */
    static Set<Integer> colorTable(BufferedImage img) {
	Set<Integer> colors = new HashSet<>();
	int w = img.getWidth();
	int h = img.getHeight();
	for (int y = 0; y < h; y++) {
	    for (int x = 0; x < w; x++) {
		int pixel = img.getRGB(x, y);
		colors.add(pixel);
	    }
	}
	return colors;
    }
    
    private static abstract class ImageOp implements BufferedImageOp {

	@Override
	public BufferedImage createCompatibleDestImage(BufferedImage src,
		ColorModel dstCM) {

	    if (dstCM == null) {
		dstCM = src.getColorModel();
	    }

	    return new BufferedImage(dstCM, dstCM.createCompatibleWritableRaster(
		    src.getWidth(), src.getHeight()), dstCM.isAlphaPremultiplied(),
		    null);
	}

	@Override
	public Rectangle2D getBounds2D(BufferedImage src) {
	    return new Rectangle(0, 0, src.getWidth(), src.getHeight());
	}

	@Override
	public Point2D getPoint2D(Point2D srcPt, Point2D dstPt) {
	    if (dstPt == null) {
		dstPt = new Point2D.Double();
	    }
	    dstPt.setLocation(srcPt.getX(), srcPt.getY());
	    return dstPt;
	}

	@Override
	public RenderingHints getRenderingHints() {
	    return null;
	}

	/**
	 * A convenience method for getting ARGB pixels from an image. This
	 * tries to avoid the performance penalty of BufferedImage.getRGB
	 * unmanaging the image.
	 *
	 * @param image a BufferedImage object
	 * @param x the left edge of the pixel block
	 * @param y the right edge of the pixel block
	 * @param width the width of the pixel arry
	 * @param height the height of the pixel arry
	 * @param pixels the array to hold the returned pixels. May be null.
	 * @return the pixels
	 * @see #setRGB
	 */
	protected int[] getRGB(BufferedImage image, int x, int y, int width,
		int height, int[] pixels) {

	    int type = image.getType();
	    if (type == BufferedImage.TYPE_INT_ARGB
		    || type == BufferedImage.TYPE_INT_RGB) {

		return (int[]) image.getRaster().getDataElements(x, y, width,
			height, pixels);
	    }
	    return image.getRGB(x, y, width, height, pixels, 0, width);
	}

	/**
	 * A convenience method for setting ARGB pixels in an image. This tries
	 * to avoid the performance penalty of BufferedImage.setRGB unmanaging
	 * the image.
	 *
	 * @param image a BufferedImage object
	 * @param x the left edge of the pixel block
	 * @param y the right edge of the pixel block
	 * @param width the width of the pixel arry
	 * @param height the height of the pixel arry
	 * @param pixels the array of pixels to set
	 * @see #getRGB
	 */
	protected void setRGB(BufferedImage image, int x, int y, int width,
		int height, int[] pixels) {

	    int type = image.getType();
	    if (type == BufferedImage.TYPE_INT_ARGB
		    || type == BufferedImage.TYPE_INT_RGB) {
		image.getRaster().setDataElements(x, y, width, height, pixels);
	    } else {
		image.setRGB(x, y, width, height, pixels, 0, width);
	    }
	}

	protected static int[] getColorHistogram(int[] rgbArray, int shift) {
	    int[] p = new int[256];
	    for (int i = 0; i < rgbArray.length; i++) {
		p[(rgbArray[i] >> shift) & 0xff]++;
	    }
	    return p;
	}

	protected static int[] getLuminanceArray(int[] rgbArray) {
	    int[] p = new int[256];
	    for (int i = 0; i < rgbArray.length; i++) {
		int rgb = rgbArray[i];

		int r = (rgb >> 16) & 0xff;
		int g = (rgb >> 8) & 0xff;
		int b = rgb & 0xff;

		p[round(0.299 * r + 0.587 * g + 0.114 * b)]++;
	    }
	    return p;
	}

	protected static int getMaximum(int clipNum, int[] arr) {
	    int max = 0, i = 255;
	    while (max < clipNum) {
		max += arr[i];
		i--;
	    }
	    i++;
	    max = i;
	    return max;
	}

	protected static int getMinimum(int clipNum, int[] arr) {
	    int min = 0, i = 0;
	    while (min < clipNum) {
		min += arr[i];
		i++;
	    }
	    i--;
	    min = i;
	    return min;
	}

	protected static int round(double d) {
	    return d >= 0 ? (int) (d + .5) : (int) (d - .5);
	}

	protected static int[] clamp(int r, int g, int b) {
	    return new int[]{r > 255 ? 255 : r < 0 ? 0 : r,
		g > 255 ? 255 : g < 0 ? 0 : g,
		b > 255 ? 255 : b < 0 ? 0 : b};
	}
        
	protected static int[][] getColors(int[] rgbArray, int largestOccs[]) {
	    int[] redPixels = new int[256];
	    int[] greenPixels = new int[256];
	    int[] bluePixels = new int[256];

	    Arrays.fill(redPixels, 0);
	    Arrays.fill(greenPixels, 0);
	    Arrays.fill(bluePixels, 0);

	    int largestOccR = 0, largestOccG = 0, largestOccB = 0;
	    int indexR = 0, indexG = 0, indexB = 0;

	    for (int i = 0; i < rgbArray.length; i++) {
		int rgb = rgbArray[i];

		int r = (rgb >> 16) & 0xff;
		int g = (rgb >> 8) & 0xff;
		int b = rgb & 0xff;

		redPixels[r]++;
		greenPixels[g]++;
		bluePixels[b]++;

		if (redPixels[r] > largestOccR) {
		    largestOccR = redPixels[r];
		    indexR = r;
		}

		if (greenPixels[g] > largestOccG) {
		    largestOccG = greenPixels[g];
		    indexG = g;
		}

		if (bluePixels[b] > largestOccB) {
		    largestOccB = bluePixels[b];
		    indexB = b;
		}
	    }

	    largestOccs[0] = indexR;
	    largestOccs[1] = indexG;
	    largestOccs[2] = indexB;

	    int[][] res = new int[3][256];

	    for (int i = 0; i < 256; i++) {
		res[0][i] = redPixels[i];
		res[1][i] = greenPixels[i];
		res[2][i] = bluePixels[i];
	    }

	    return res;
	}

    }

    private static abstract class PointImageOp extends ImageOp {

	@Override
	public BufferedImage filter(BufferedImage src, BufferedImage dest) {
	    int width = src.getWidth();
	    int height = src.getHeight();
	    int type = src.getType();
	    WritableRaster srcRaster = src.getRaster();

	    if (dest == null) {
		dest = createCompatibleDestImage(src, null);
	    }
	    WritableRaster dstRaster = dest.getRaster();

	    int[] inPixels = new int[width];
	    for (int y = 0; y < height; y++) {
		// We try to avoid calling getRGB on images as it causes them to 
		// become unmanaged, causing horrible performance problems.
		if (type == BufferedImage.TYPE_INT_ARGB) {
		    srcRaster.getDataElements(0, y, width, 1, inPixels);
		    for (int x = 0; x < width; x++) {
			inPixels[x] = filterRGB(x, y, inPixels[x]);
		    }
		    dstRaster.setDataElements(0, y, width, 1, inPixels);
		} else {
		    src.getRGB(0, y, width, 1, inPixels, 0, width);
		    for (int x = 0; x < width; x++) {
			inPixels[x] = filterRGB(x, y, inPixels[x]);
		    }
		    dest.setRGB(0, y, width, 1, inPixels, 0, width);
		}
	    }

	    return dest;
	}

	public abstract int filterRGB(int x, int y, int rgb);

    }

}
